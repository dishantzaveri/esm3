# -*- coding: utf-8 -*-
"""Pipeline.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ymphh9M4Vcvh5Cn9tijHkJ1PcY-DSPX4

##  ESM-3 Inverse Folding Pipeline – Summary

This notebook implements an end-to-end inverse folding pipeline using the ESM-3 model. It starts by loading 3D protein backbone structures (Cα atoms) from `.npz` files in the ProteinInvBench CATH dataset. Each structure is passed into ESM-3 using the `"structure"` track to generate a plausible amino acid sequence.

Optionally, the generated sequence is roundtripped through ESM-3 again using the `"sequence"` track to predict a new structure. The pipeline then evaluates how consistent the predictions are by calculating the RMSD (Root Mean Square Deviation) between the original and roundtripped coordinates.

If the original sequence is available in the dataset, it also computes sequence recovery — the percentage of residues correctly predicted by the model. All results, including filenames, predicted sequences, roundtrip structures, RMSD values, and sequence recovery scores, are saved to a JSON file for further analysis.

This setup aligns with key ProteinInvBench metrics and allows systematic benchmarking of ESM-3's inverse design capabilities.
"""

from huggingface_hub import login
from esm.sdk.api import ESM3InferenceClient, ESMProtein, GenerationConfig, ESMProteinError
import numpy as np
import os, json, re
from tqdm import tqdm
from scipy.spatial.distance import cdist

login(token="<your_token>")
model = ESM3InferenceClient("esm3-open").to("cuda")

input_dir = "ProteinInvBench/data/CATH"
output_file = "esm3_inverse_results.json"
all_results = []

files = [f for f in os.listdir(input_dir) if f.endswith(".npz")]

def compute_rmsd(A, B):
    D = cdist(A, B, metric='euclidean')
    return np.sqrt(np.mean(np.min(D, axis=1)))

def compute_sequence_recovery(pred_seq, true_seq):
    if not true_seq or len(pred_seq) != len(true_seq):
        return None
    return sum(p == t for p, t in zip(pred_seq, true_seq)) / len(true_seq)

for file in tqdm(files):
    path = os.path.join(input_dir, file)
    try:
        data = np.load(path, allow_pickle=True)
        coords = data['positions'][:, 1, :]
        coords = coords[~np.isnan(coords).any(axis=1)]
        true_seq = data['seq'] if 'seq' in data else None

        if len(coords) < 50 or len(coords) > 1024:
            continue
        protein = ESMProtein(coordinates=coords)

        protein = model.generate(protein, GenerationConfig(track="sequence", num_steps=8))
        if isinstance(protein, ESMProteinError):
            continue
        sequence = protein.sequence

        protein.coordinates = None
        protein = model.generate(protein, GenerationConfig(track="structure", num_steps=8))
        if isinstance(protein, ESMProteinError):
            continue
        coords2 = protein.coordinates

        rmsd = None
        if coords2 is not None:
            try:
                min_len = min(len(coords), len(coords2))
                rmsd = compute_rmsd(coords[:min_len], coords2[:min_len])
            except:
                pass

        recovery = compute_sequence_recovery(sequence, true_seq.item() if true_seq is not None else None)

        result = {
            "filename": file,
            "length": len(coords),
            "predicted_sequence": sequence,
            "true_sequence": true_seq.item() if true_seq is not None else None,
            "sequence_recovery": recovery,
            "roundtrip_coords": coords2.tolist() if coords2 is not None else None,
            "rmsd": rmsd
        }
        all_results.append(result)

    except Exception as e:
        continue

with open(output_file, "w") as f:
    json.dump(all_results, f, indent=2)

print(f"Saved {len(all_results)} results to {output_file}")